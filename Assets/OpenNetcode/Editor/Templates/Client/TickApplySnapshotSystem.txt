using OpenNetcode.Client.Components;
using OpenNetcode.Shared.Systems;
using OpenNetcode.Shared.Time;
using Unity.Burst;
using Unity.Entities;
using UnityEngine;

//<using>

namespace Client.Generated
{
    [UpdateInGroup(typeof(TickPreSimulationSystemGroup), OrderLast = true)]
    [DisableAutoCreation]
    public partial class TickApplySnapshotSystem : SystemBase
    {
        private TickSystem _tickSystem;
        
        //<template:publicsnapshot>
        //private EntityQuery _##TYPELOWER##Query;
        //</template>
        //<template:privatesnapshot>
        //private EntityQuery _##TYPELOWER##Query;
        //</template>
        //<template:publicevent>
        //private EntityQuery _##TYPELOWER##Query;
        //</template>

        protected override void OnCreate()
        {
            _tickSystem = World.GetExistingSystem<TickSystem>();
            
            //<template:publicsnapshot>
            //_##TYPELOWER##Query = GetEntityQuery(
            //    ComponentType.Exclude<Prediction<##TYPE##>>(),
            //    ComponentType.ReadOnly<SnapshotBufferElement<##TYPE##>>(),
            //    ComponentType.ReadWrite<##TYPE##>());
            //</template>
            //<template:privatesnapshot>
            //_##TYPELOWER##Query = GetEntityQuery(
            //    ComponentType.Exclude<Prediction<##TYPE##>>(),
            //    ComponentType.ReadOnly<SnapshotBufferElement<##TYPE##>>(),
            //    ComponentType.ReadWrite<##TYPE##>());
            //</template>

            //<template:publicevent>
            //_##TYPELOWER##Query = GetEntityQuery(
            //    ComponentType.ReadOnly<SnapshotBufferElement<##TYPE##>>(),
            //    ComponentType.ReadWrite<##TYPE##>());
            //</template>

            
            base.OnCreate();
        }

        protected override void OnUpdate()
        {
            double rttHalf = _tickSystem.RttHalf / 2;
            double tickFloat = _tickSystem.TickFloat;
            double tickServer = tickFloat - (rttHalf + TimeConfig.CommandBufferLengthMs) / 1000f * TimeConfig.TicksPerSecond;
            double tickFrom = tickServer - TimeConfig.TicksPerSecond * Mathf.Min(0.1f, 1f / TimeConfig.SnapshotsPerSecond);

            //<template:publicsnapshot>
            //ApplyFromBufferJob<##TYPE##> ##TYPELOWER##Job = new ApplyFromBufferJob<##TYPE##>()
            //{
            //    Tick = (int) tickFrom,
            //    SnapshotBufferFromEntity = GetBufferTypeHandle<SnapshotBufferElement<##TYPE##>>(true),
            //    ComponentDataFromEntity = GetComponentTypeHandle<##TYPE##>()
            //};
            //Dependency = ##TYPELOWER##Job.ScheduleParallel(_##TYPELOWER##Query, Dependency);
            //</template>
            //<template:privatesnapshot>
            //ApplyFromBufferJob<##TYPE##> ##TYPELOWER##Job = new ApplyFromBufferJob<##TYPE##>()
            //{
            //    Tick = (int) tickFrom,
            //    SnapshotBufferFromEntity = GetBufferTypeHandle<SnapshotBufferElement<##TYPE##>>(true),
            //    ComponentDataFromEntity = GetComponentTypeHandle<##TYPE##>()
            //};
            //Dependency = ##TYPELOWER##Job.ScheduleParallel(_##TYPELOWER##Query, Dependency);
            //</template>

            //<template:publicevent>
            //AddEventFromBufferJob<##TYPE##> ##TYPELOWER##Job = new AddEventFromBufferJob<##TYPE##>()
            //{
            //    Tick = (int) tickFrom,
            //    SnapshotBufferFromEntity = GetBufferTypeHandle<SnapshotBufferElement<##TYPE##>>(true),
            //    BufferFromEntity = GetBufferTypeHandle<##TYPE##>()
            //};
            //Dependency = ##TYPELOWER##Job.ScheduleParallel(_##TYPELOWER##Query, Dependency);
            //</template>

            Dependency.Complete();
        }

        [BurstCompile]
        private struct ApplyFromBufferJob<T> : IJobChunk where T : unmanaged, IComponentData
        {
            public int Tick;
            public ComponentTypeHandle<T> ComponentDataFromEntity;
            public BufferTypeHandle<SnapshotBufferElement<T>> SnapshotBufferFromEntity;
        
            public void Execute(ArchetypeChunk chunk, int chunkIndex, int firstEntityIndex)
            {
                var components = chunk.GetNativeArray(ComponentDataFromEntity);
                var snapshotBuffers = chunk.GetBufferAccessor(SnapshotBufferFromEntity);

                for (int i = 0; i < chunk.Count; i++)
                {
                    var buffer = snapshotBuffers[i];
                    var element = buffer[Tick % TimeConfig.SnapshotsPerSecond];
                    if (element.Tick == Tick)
                    {
                        components[i] = element.Value;
                    }
                }
            }
        }
        
        [BurstCompile]
        private struct AddEventFromBufferJob<T> : IJobChunk where T : unmanaged, IBufferElementData
        {
            public int Tick;
            public BufferTypeHandle<T> BufferFromEntity;
            public BufferTypeHandle<SnapshotBufferElement<T>> SnapshotBufferFromEntity;
        
            public void Execute(ArchetypeChunk chunk, int chunkIndex, int firstEntityIndex)
            {
                var buffers = chunk.GetBufferAccessor(BufferFromEntity);
                var snapshotBuffers = chunk.GetBufferAccessor(SnapshotBufferFromEntity);

                for (int i = 0; i < chunk.Count; i++)
                {
                    var buffer = snapshotBuffers[i];
                    var element = buffer[Tick % TimeConfig.SnapshotsPerSecond];
                    
                    if (element.Tick == Tick)
                    {
                        buffers[i].Add(element.Value);
                    }
                }
            }
        }
    }
}
